"""
GlitchForge Pentester - Orchestrator
Stage 1.5: Validates scanner findings by attempting controlled exploitation.
Follows Shannon's "No Exploit, No Report" philosophy.
"""

from typing import Dict, List, Optional, Callable

from app.core.scanner.base_scanner import VulnerabilityResult, VulnerabilityType
from app.utils.logger import get_logger

from .sqli_validator import SQLiValidator
from .xss_validator import XSSValidator
from .csrf_validator import CSRFValidator
from .data_models import PentestResult, VerificationStatus


class PentestOrchestrator:
    """
    Stage 1.5: Pentest Validation Orchestrator

    Takes scan results and validates each vulnerability by attempting
    controlled exploitation. Only confirmed/likely findings pass through.

    100% local - no external APIs, no credits, no cloud services.
    Pure Python exploitation techniques running on the local machine.
    """

    def __init__(self, config: Dict):
        self.config = config
        self.logger = get_logger("PentestOrchestrator")

        self.validators = {
            VulnerabilityType.SQL_INJECTION: SQLiValidator(config),
            VulnerabilityType.XSS: XSSValidator(config),
            VulnerabilityType.CSRF: CSRFValidator(config),
        }

    def validate_all(
        self,
        vulnerabilities: List[VulnerabilityResult],
        max_per_type: int = 5,
        progress_callback: Optional[Callable] = None
    ) -> List[PentestResult]:
        """
        Validate all discovered vulnerabilities.

        Args:
            vulnerabilities: Scanner findings to validate
            max_per_type: Max vulnerabilities to validate per type
            progress_callback: Optional callback(current, total, confirmed, technique)

        Returns:
            List of PentestResult with verification status and evidence
        """
        results = []
        total = min(len(vulnerabilities), max_per_type * len(self.validators))
        current = 0
        confirmed = 0

        # Group by type
        by_type: Dict[VulnerabilityType, List[VulnerabilityResult]] = {}
        for vuln in vulnerabilities:
            by_type.setdefault(vuln.vuln_type, []).append(vuln)

        for vuln_type, type_vulns in by_type.items():
            validator = self.validators.get(vuln_type)
            if not validator:
                self.logger.warning(f"No validator for {vuln_type.value}")
                continue

            # Sort by confidence descending, validate most likely first
            sorted_vulns = sorted(type_vulns, key=lambda v: v.confidence, reverse=True)
            to_validate = sorted_vulns[:max_per_type]

            self.logger.info(
                f"Validating {len(to_validate)} {vuln_type.value} findings..."
            )

            for vuln in to_validate:
                current += 1

                if progress_callback:
                    progress_callback(current, total, confirmed, vuln_type.value)

                try:
                    result = validator.validate(vuln)
                    results.append(result)

                    if result.verification_status == VerificationStatus.CONFIRMED:
                        confirmed += 1

                    status_label = result.verification_status.value.upper()
                    self.logger.info(
                        f"  [{status_label}] {vuln.vuln_type.value} on "
                        f"'{vuln.parameter}' (confidence: {result.confidence:.0%})"
                    )

                except Exception as e:
                    self.logger.error(f"  Validation error for {vuln.parameter}: {e}")
                    results.append(PentestResult(
                        vulnerability_url=vuln.url,
                        vulnerability_parameter=vuln.parameter,
                        vulnerability_type=vuln.vuln_type.value,
                        verification_status=VerificationStatus.UNVERIFIED,
                        confidence=0.0,
                        error_message=str(e)
                    ))

        # Final summary
        total_tested = len(results)
        confirmed_count = sum(
            1 for r in results
            if r.verification_status == VerificationStatus.CONFIRMED
        )
        likely_count = sum(
            1 for r in results
            if r.verification_status == VerificationStatus.LIKELY
        )
        filtered_count = sum(
            1 for r in results
            if r.verification_status in (
                VerificationStatus.UNVERIFIED,
                VerificationStatus.FALSE_POSITIVE
            )
        )

        self.logger.info(
            f"\nPentest Validation Complete:"
            f"\n  Tested: {total_tested}"
            f"\n  Confirmed: {confirmed_count}"
            f"\n  Likely: {likely_count}"
            f"\n  Filtered: {filtered_count}"
        )

        return results
