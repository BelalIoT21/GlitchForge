"""
GlitchForge Pentester - Base Validator
Abstract base class for vulnerability exploitation validators.
Mirrors the BaseScanner pattern for consistency.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional
import time
import requests
from urllib.parse import urlencode, quote

from app.utils.logger import get_logger
from app.core.scanner.base_scanner import VulnerabilityResult
from .data_models import (
    PentestResult, PentestEvidence, HttpExchange,
    VerificationStatus, ExploitTechnique
)


class BaseValidator(ABC):
    """
    Base class for vulnerability validators (pentest agents).

    Design principles (matching BaseScanner style):
    - Controlled exploitation only - never destructive
    - Capture full HTTP evidence for reproducibility
    - Generate cURL commands for PoC reproduction
    - Time-boxed: each validation attempt has a timeout
    - Safe: no DROP TABLE, no persistent changes, read-only proofs
    """

    MAX_VALIDATION_TIME = 30

    FORBIDDEN_KEYWORDS = [
        'DROP', 'DELETE FROM', 'TRUNCATE', 'ALTER TABLE',
        'INSERT INTO', 'UPDATE ', 'EXEC ', 'xp_cmdshell',
        'SHUTDOWN', 'CREATE ', 'GRANT ', 'REVOKE '
    ]

    def __init__(self, config: Dict):
        self.config = config
        self.logger = get_logger(self.__class__.__name__)
        self.timeout = config.get('timeout', 15)
        self.user_agent = config.get('user_agent', 'GlitchForge/2.0 PentestValidator')
        self.cookies = config.get('cookies', {})
        self.request_count = 0

    def make_request(
        self,
        url: str,
        method: str = 'GET',
        params: Dict = None,
        data: Dict = None,
        headers: Dict = None,
        allow_redirects: bool = True
    ) -> Optional[requests.Response]:
        """Make HTTP request and return response"""
        try:
            req_headers = {'User-Agent': self.user_agent}
            if headers:
                req_headers.update(headers)
            self.request_count += 1

            if method.upper() == 'GET':
                response = requests.get(
                    url, params=params, headers=req_headers,
                    cookies=self.cookies, timeout=self.timeout,
                    allow_redirects=allow_redirects, verify=False
                )
            else:
                response = requests.post(
                    url, data=data, headers=req_headers,
                    cookies=self.cookies, timeout=self.timeout,
                    allow_redirects=allow_redirects, verify=False
                )
            return response
        except requests.RequestException as e:
            self.logger.debug(f"Request failed: {e}")
            return None

    def capture_exchange(
        self,
        response: requests.Response,
        request_body: Optional[str] = None
    ) -> HttpExchange:
        """Capture an HTTP exchange for evidence"""
        return HttpExchange(
            method=response.request.method,
            url=str(response.request.url),
            headers=dict(response.request.headers),
            body=request_body,
            status_code=response.status_code,
            response_headers=dict(response.headers),
            response_body=response.text[:2000],
            response_time_ms=response.elapsed.total_seconds() * 1000
        )

    def generate_curl(
        self,
        url: str,
        method: str = 'GET',
        params: Dict = None,
        data: Dict = None,
        cookies: Dict = None
    ) -> str:
        """Generate a reproducible cURL command for PoC"""
        parts = ['curl']
        if method.upper() != 'GET':
            parts.append(f'-X {method.upper()}')

        full_url = url
        if params:
            full_url += '?' + urlencode(params, quote_via=quote)
        parts.append(f"'{full_url}'")

        parts.append(f"-H 'User-Agent: {self.user_agent}'")

        effective_cookies = cookies or self.cookies
        if effective_cookies:
            cookie_str = '; '.join(f'{k}={v}' for k, v in effective_cookies.items())
            parts.append(f"-b '{cookie_str}'")

        if data:
            parts.append(f"-d '{urlencode(data)}'")

        parts.append('--insecure')
        return ' \\\n  '.join(parts)

    def is_safe_payload(self, payload: str) -> bool:
        """Check that a payload does not contain destructive SQL"""
        upper_payload = payload.upper()
        return not any(kw in upper_payload for kw in self.FORBIDDEN_KEYWORDS)

    @abstractmethod
    def validate(self, vuln: VulnerabilityResult) -> PentestResult:
        """
        Attempt to validate/exploit a vulnerability.

        Args:
            vuln: The scanner-detected vulnerability to validate

        Returns:
            PentestResult with verification status and evidence
        """
        pass
