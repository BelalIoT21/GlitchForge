"""
GlitchForge Pentester - XSS Validator
Proves Cross-Site Scripting vulnerabilities through controlled reflection testing.
"""

import re
import time
import html
import secrets
from typing import Dict, Optional
from urllib.parse import urlparse, parse_qs

from app.core.scanner.base_scanner import VulnerabilityResult
from .base_validator import BaseValidator
from .data_models import (
    PentestResult, PentestEvidence,
    VerificationStatus, ExploitTechnique
)


class XSSValidator(BaseValidator):
    """
    XSS exploitation validator.

    Techniques:
    1. Canary reflection: Inject unique marker and verify unescaped reflection
    2. Context-aware escape: Try payloads that escape different HTML contexts
    3. CSP check: Analyze Content-Security-Policy to assess real-world impact
    """

    def _parse_url(self, vuln: VulnerabilityResult):
        parsed = urlparse(vuln.url)
        base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
        existing_params = {}
        if parsed.query:
            for key, values in parse_qs(parsed.query).items():
                existing_params[key] = values[0] if values else ''
        return base_url, existing_params

    def validate(self, vuln: VulnerabilityResult) -> PentestResult:
        """Attempt to validate XSS through escalating techniques"""
        start_time = time.time()
        attempts = 0

        base_url, existing_params = self._parse_url(vuln)

        # Technique 1: Canary reflection with unique marker
        result = self._try_canary_reflection(vuln, base_url, existing_params)
        attempts += 1
        if result and result.verification_status == VerificationStatus.CONFIRMED:
            result.duration_seconds = time.time() - start_time
            result.attempts = attempts
            return result

        # Technique 2: Context-aware escape payloads
        result = self._try_context_escape(vuln, base_url, existing_params)
        attempts += 1
        if result and result.verification_status == VerificationStatus.CONFIRMED:
            result.duration_seconds = time.time() - start_time
            result.attempts = attempts
            return result

        # If reflection detected but CSP blocks execution, mark as LIKELY
        csp_info = self._check_csp(vuln, base_url, existing_params)
        if csp_info.get('reflected_but_csp_blocks'):
            return PentestResult(
                vulnerability_url=vuln.url,
                vulnerability_parameter=vuln.parameter,
                vulnerability_type=vuln.vuln_type.value,
                verification_status=VerificationStatus.LIKELY,
                confidence=0.75,
                evidence=csp_info.get('evidence'),
                attempts=attempts,
                duration_seconds=time.time() - start_time
            )

        # None confirmed
        return PentestResult(
            vulnerability_url=vuln.url,
            vulnerability_parameter=vuln.parameter,
            vulnerability_type=vuln.vuln_type.value,
            verification_status=(
                VerificationStatus.LIKELY if vuln.confidence >= 0.90
                else VerificationStatus.UNVERIFIED
            ),
            confidence=vuln.confidence * 0.7,
            attempts=attempts,
            duration_seconds=time.time() - start_time
        )

    def _try_canary_reflection(
        self,
        vuln: VulnerabilityResult,
        base_url: str,
        existing_params: Dict[str, str]
    ) -> Optional[PentestResult]:
        """
        Inject a unique canary tag and verify it appears unescaped.
        Uses a random ID to avoid matching cached/template content.
        """
        self.logger.debug(f"Trying canary reflection on {vuln.parameter}")

        canary_id = secrets.token_hex(4)
        canary_payloads = [
            (f"<gftest_{canary_id} onload=1>", f"gftest_{canary_id}"),
            (f"<script>/*gfcanary_{canary_id}*/</script>", f"gfcanary_{canary_id}"),
            (f"<img src=x onerror=gfxss_{canary_id}>", f"gfxss_{canary_id}"),
        ]

        for payload, marker in canary_payloads:
            test_params = existing_params.copy()
            test_params[vuln.parameter] = payload

            response = self.make_request(base_url, params=test_params)
            if not response:
                continue

            response_text = response.text
            escaped_payload = html.escape(payload)

            # Check if payload is escaped (safe)
            if escaped_payload.lower() in response_text.lower():
                self.logger.debug("Canary found but HTML-escaped (safe)")
                continue

            # Check if payload appears unescaped (vulnerable)
            if marker in response_text:
                # Extract context around the reflection
                idx = response_text.find(marker)
                context_start = max(0, idx - 80)
                context_end = min(len(response_text), idx + len(marker) + 80)
                context = response_text[context_start:context_end]

                self.logger.info(f"XSS canary reflected unescaped: {marker}")

                exchange = self.capture_exchange(response)
                curl_cmd = self.generate_curl(base_url, params=test_params)

                evidence = PentestEvidence(
                    technique=ExploitTechnique.XSS_REFLECTED,
                    http_exchanges=[exchange],
                    poc_command=curl_cmd,
                    extracted_data=[
                        f"Injected payload: {payload}",
                        f"Reflected unescaped in response HTML",
                        f"Context: ...{context}..."
                    ],
                    impact_description=(
                        f"Reflected XSS confirmed. The payload '{payload}' is reflected "
                        f"unescaped in the page HTML via the '{vuln.parameter}' parameter. "
                        f"An attacker could craft a malicious URL that executes arbitrary "
                        f"JavaScript in the victim's browser, stealing session cookies, "
                        f"performing actions on behalf of the user, or redirecting to phishing pages."
                    ),
                    reproduction_steps=[
                        f"Navigate to {vuln.url}",
                        f"Set the '{vuln.parameter}' parameter to: {payload}",
                        f"View page source and search for '{marker}'",
                        "The unescaped HTML tag confirms arbitrary HTML/script injection"
                    ]
                )

                return PentestResult(
                    vulnerability_url=vuln.url,
                    vulnerability_parameter=vuln.parameter,
                    vulnerability_type=vuln.vuln_type.value,
                    verification_status=VerificationStatus.CONFIRMED,
                    confidence=0.97,
                    evidence=evidence
                )

        return None

    def _try_context_escape(
        self,
        vuln: VulnerabilityResult,
        base_url: str,
        existing_params: Dict[str, str]
    ) -> Optional[PentestResult]:
        """
        Try context-specific escape payloads.
        First, inject a simple probe to determine HTML context, then use
        appropriate escape sequences.
        """
        self.logger.debug(f"Trying context escape on {vuln.parameter}")

        # First, inject a simple text probe to find the reflection context
        probe = f"GFPROBE_{secrets.token_hex(3)}"
        probe_params = existing_params.copy()
        probe_params[vuln.parameter] = probe

        probe_resp = self.make_request(base_url, params=probe_params)
        if not probe_resp or probe not in probe_resp.text:
            return None

        # Find the context of the probe
        text = probe_resp.text
        idx = text.find(probe)
        before = text[max(0, idx - 50):idx]
        after = text[idx + len(probe):idx + len(probe) + 50]

        # Determine context and craft escape payloads
        context_payloads = []

        # Inside an HTML attribute (e.g., value="PROBE")
        if re.search(r'["\']$', before.rstrip()):
            quote = before.rstrip()[-1]
            context_payloads.append(
                (f'{quote} onmouseover=alert(1) {quote}',
                 'onmouseover=alert(1)',
                 'attribute_event_handler')
            )
            context_payloads.append(
                (f'{quote}><script>alert(1)</script><{quote}',
                 '<script>alert(1)</script>',
                 'attribute_tag_break')
            )

        # Inside a <script> block
        if '<script' in before.lower():
            context_payloads.append(
                ('</script><script>alert(1)</script>',
                 '</script><script>alert(1)</script>',
                 'script_context_break')
            )

        # Inside regular HTML body (default)
        context_payloads.append(
            (f'<svg onload=alert(1)>',
             '<svg onload=alert(1)>',
             'svg_event_handler')
        )

        for payload, search_marker, context_name in context_payloads:
            test_params = existing_params.copy()
            test_params[vuln.parameter] = payload

            response = self.make_request(base_url, params=test_params)
            if not response:
                continue

            # Check for unescaped reflection
            escaped = html.escape(search_marker)
            if escaped.lower() in response.text.lower():
                continue  # Escaped, not vulnerable

            if search_marker.lower() in response.text.lower():
                self.logger.info(f"Context escape XSS confirmed: {context_name}")

                exchange = self.capture_exchange(response)
                curl_cmd = self.generate_curl(base_url, params=test_params)

                evidence = PentestEvidence(
                    technique=ExploitTechnique.XSS_CONTEXT_ESCAPE,
                    http_exchanges=[exchange],
                    poc_command=curl_cmd,
                    extracted_data=[
                        f"HTML context: {context_name}",
                        f"Escape payload: {payload}",
                        f"Reflected unescaped in response"
                    ],
                    impact_description=(
                        f"XSS confirmed via context-aware escape ({context_name}). "
                        f"The application reflects user input in a {context_name} context "
                        f"without proper encoding. An attacker can break out of the current "
                        f"HTML context and inject executable JavaScript."
                    ),
                    reproduction_steps=[
                        f"Navigate to {vuln.url}",
                        f"Set '{vuln.parameter}' to: {payload}",
                        f"The payload escapes the {context_name} context",
                        "Arbitrary JavaScript can execute in the victim's browser"
                    ]
                )

                return PentestResult(
                    vulnerability_url=vuln.url,
                    vulnerability_parameter=vuln.parameter,
                    vulnerability_type=vuln.vuln_type.value,
                    verification_status=VerificationStatus.CONFIRMED,
                    confidence=0.95,
                    evidence=evidence
                )

        return None

    def _check_csp(
        self,
        vuln: VulnerabilityResult,
        base_url: str,
        existing_params: Dict[str, str]
    ) -> Dict:
        """
        Check Content-Security-Policy headers.
        If CSP blocks inline scripts, XSS may be mitigated even if reflected.
        """
        test_params = existing_params.copy()
        test_params[vuln.parameter] = "<script>alert(1)</script>"

        response = self.make_request(base_url, params=test_params)
        if not response:
            return {}

        csp = response.headers.get('Content-Security-Policy', '')

        # Check if payload is reflected
        payload_reflected = '<script>alert(1)</script>' in response.text

        if not payload_reflected:
            return {}

        # If reflected but CSP exists with script-src restriction
        if csp and ('script-src' in csp or "default-src" in csp):
            has_unsafe_inline = "'unsafe-inline'" in csp
            has_nonce = 'nonce-' in csp

            if not has_unsafe_inline:
                exchange = self.capture_exchange(response)
                curl_cmd = self.generate_curl(base_url, params=test_params)

                evidence = PentestEvidence(
                    technique=ExploitTechnique.XSS_CSP_BYPASS,
                    http_exchanges=[exchange],
                    poc_command=curl_cmd,
                    extracted_data=[
                        f"Payload reflected: Yes",
                        f"CSP header present: Yes",
                        f"CSP: {csp[:200]}",
                        f"unsafe-inline: {has_unsafe_inline}",
                        f"Nonce-based: {has_nonce}",
                        "Script execution likely blocked by CSP"
                    ],
                    impact_description=(
                        f"XSS payload is reflected unescaped but Content-Security-Policy "
                        f"may prevent script execution. The vulnerability exists in the code "
                        f"but the CSP header provides a defense-in-depth mitigation. "
                        f"CSP bypasses may still be possible depending on the policy."
                    ),
                    reproduction_steps=[
                        f"Set '{vuln.parameter}' to: <script>alert(1)</script>",
                        "Observe the payload is reflected in the response body",
                        f"Note the CSP header: {csp[:100]}...",
                        "CSP blocks inline script execution (defense-in-depth)"
                    ]
                )

                return {
                    'reflected_but_csp_blocks': True,
                    'evidence': evidence
                }

        return {}
